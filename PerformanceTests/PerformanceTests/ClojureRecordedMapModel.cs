using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using clojure.lang;
using UpdateControls;
using System.Linq;

namespace Strive.DataModel.Tests
{
    /// <summary>
    /// Objects stored in this Map need to be immutable to ensure they are not modified externally,
    /// so that all changes are recorded in the history.
    /// History is stored in an ordered map of version to state,
    /// where the state is a map of keys to values.
    /// </summary>
    public class ClojureRecordedMapModel<TKeyType, TValueType> : IEnumerable<TValueType>
    {
        private IPersistentMap _history = PersistentTreeMap.EMPTY;
        private IPersistentMap _currentMap = PersistentTreeMap.EMPTY;

        public int CurrentVersion { get; private set; }

        public ClojureRecordedMapModel()
        {
            CurrentVersion = -1;
            Clear();
        }

        private IPersistentMap Map
        {
            get { return _currentMap; }
            set {
                _currentMap = value;
                _history = _history.assoc(++CurrentVersion, value);
            }
        }

        public ClojureRecordedMapModel(IEnumerable<KeyValuePair<TKeyType, TValueType>> keyValuePairs)
            : this()
        {
            Contract.Requires<ArgumentNullException>(keyValuePairs != null);

            foreach (var e in keyValuePairs)
                Map = Map.assoc(e.Key, e.Value);
        }

        #region Independent properties
        // Generated by Update Controls --------------------------------
        private readonly Independent _indEntities = new Independent();

        public void Set(TKeyType key, TValueType value)
        {
            _indEntities.OnSet();
            Map = Map.assoc(key, value);
        }

        public void Remove(TKeyType key)
        {
            _indEntities.OnSet();
            Map = (PersistentTreeMap)RT.dissoc(Map, key);
        }

        public TValueType Get(TKeyType id)
        {
            _indEntities.OnGet();
            return (TValueType)RT.get(Map, id);
        }

        public IEnumerable<TValueType> Values
        {
            get { _indEntities.OnGet(); return ((PersistentTreeMap)Map).Values.Cast<TValueType>(); }
        }

        public int Count
        {
            get { _indEntities.OnGet(); return ((PersistentTreeMap)Map).Count; }
        }

        public void Clear()
        {
            _indEntities.OnSet();
            Map = PersistentTreeMap.EMPTY;
        }

        public bool ContainsKey(TKeyType key)
        {
            _indEntities.OnGet();
            return Map.containsKey(key);
        }

        // End generated code --------------------------------
        #endregion

        #region IEnumerable<TValueType> Members

        public IEnumerator<TValueType> GetEnumerator()
        {
            return ((PersistentTreeMap)Map).Values.Cast<TValueType>().GetEnumerator();
        }

        #endregion

        #region IEnumerable Members

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return ((PersistentTreeMap)Map).Values.GetEnumerator();
        }

        #endregion
    }
}
